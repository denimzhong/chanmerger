// Copyright 2021 Patrick Zhong.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.

// Merger is a tool to automate the creation of method that merges multiple channels into one.
//
// For example, given the type chan int, run this command
//
// chanmerger -type='chan int'
//
// in the same diretory will create a file named chan_int_merge.go, in same package,
// containing a definition of
//
// func mergeIntChan(in ...chan int) chan int
//
// That method will receive all values from input channels, and send them to a new ouput
// channel, which is called fanin.
//
package main // import "github.com/patrickio/chanmerger"

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeNames = flag.String("type", "", "comma-seperated list of type names; must be set")
	readOnly  = flag.Bool("readonly", false, "generate readonly channel instead of origin one")
	output    = flag.String("output", "", "output file name; default srcdir/<type>_merge.go")
	buildTags = flag.String("tags", "", "comma-seperater list of build tags to apply")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of chanmerger:\n")
	fmt.Fprintf(os.Stderr, "\tchanmerger [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tchanmerger [flags] -type T files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetPrefix("chanmerger: ")
	flag.Usage = Usage
	flag.Parse()

	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	types := strings.Split(*typeNames, ",")

	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	args := flag.Args()

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else if len(args) > 1 {
		dir = filepath.Dir(args[0])
	} else {
		dir, _ = os.Getwd()
	}

	g := &Generator{readonly: *readOnly}
	g.parsePackages(args, tags)

	g.Printf("// Code generated by \"chanmerger %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", g.pkg.name)
	g.Printf("\n")

	for _, typeName := range types {
		g.importPackage(typeName)
	}
	for _, typeName := range types {
		g.generate(typeName)
	}

	src := g.format()
	output := *output
	if len(output) == 0 {
		typeName := types[0]
		typeName = strings.ReplaceAll(typeName, ".", "_")
		baseName := fmt.Sprintf("%s_chan_merge.go", typeName)
		output = filepath.Join(dir, strings.ToLower(baseName))
	}

	err := ioutil.WriteFile(output, src, 0644)
	if err != nil {
		log.Fatalf("write output: %v", err)
	}
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

type Generator struct {
	buf      bytes.Buffer
	pkg      *Package
	readonly bool
}

type Package struct {
	name    string
	imports map[string]*Package
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) parsePackages(patterns, tags []string) {
	cnf := &packages.Config{
		Mode:       packages.NeedImports | packages.NeedName,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cnf, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %s packages found", pkgs)
	}
	g.addPackage(pkgs[0])
}

func (g *Generator) addPackage(pkg *packages.Package) {
	g.pkg = &Package{
		name: pkg.Name,
	}
	for k, v := range pkg.Imports {
		if g.pkg.imports == nil {
			g.pkg.imports = make(map[string]*Package)
		}
		g.pkg.imports[k] = &Package{
			name: v.Name,
		}
	}
}

func (g *Generator) importPackage(typeName string) {
	ss := strings.Split(typeName, ".")
	if len(ss) < 2 {
		return
	}
	for importPath := range g.pkg.imports {
		if filepath.Base(importPath) == ss[0] {
			g.Printf("import \"%s\"\n", importPath)
		}
	}
}

func (g *Generator) generate(typeName string) {
	fname := stringFirstUppper(typeName)
	fname = strings.ReplaceAll(fname, ".", "")
	cname := "chan"
	if g.readonly {
		cname = "<-" + cname
	}

	g.Printf("\n")
	g.Printf(stringMergeRecursion, typeName, fname, cname)
	g.Printf("\n\n")
	g.Printf(stringMergeTwo, typeName, fname, cname)
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %v", err)
		return g.buf.Bytes()
	}
	return src
}

func stringFirstUppper(s string) string {
	bs := []byte(s)
	if bs[0] >= 97 && bs[0] <= 122 { // 97:a, 122:z
		bs[0] -= 32
	}
	return string(bs)
}

var stringMergeRecursion = `func merge%[2]sChan(in ...%[3]s %[1]s) %[3]s %[1]s {
	emptyChanFn := func() %[3]s %[1]s {empty:=make(chan %[1]s);close(empty);return (%[3]s %[1]s)(empty);}
	len:=len(in)
	switch len {
	case 0:
		return emptyChanFn()
	case 1:
		return in[0]
	case 2:
		return mergeTwo%[2]sChan(in[0], in[1])
	default:
		left := merge%[2]sChan(in[:len/2]...)
		right := merge%[2]sChan(in[len/2:]...)
		return merge%[2]sChan(left, right)
	}
}`

var stringMergeTwo = `func mergeTwo%[2]sChan(ch1, ch2 %[3]s %[1]s) %[3]s %[1]s {
	merge := make(chan %[1]s)
	go func() {
		defer close(merge)
		flag := uint8(0)
		for {
			select {
			case v, ok := <-ch1:
				if !ok {
					flag |= 1
				} else {
					merge <- v
				}
			case v, ok := <-ch2:
				if !ok {
					flag |= 1
				} else {
					merge <- v
				}
			}
			if flag&1 == 1 && ch1 != nil {
				ch1 = nil
			}
			if flag&2 == 2 && ch2 != nil {
				ch2 = nil
			}
			if flag&3 == 3 {
				break
			}
		}
	}()
	return merge
}`
